using System.Reflection;
using System.Text;
using Meziantou.Polyfill.Generator;

var assembly = Assembly.GetExecutingAssembly();
var polyfills = assembly.GetManifestResourceNames()
      .OrderBy(_ => _, StringComparer.Ordinal)
      .Select((item, index) =>
      {
          var typeName = Path.GetFileNameWithoutExtension(item).Replace(';', ':');
          return new Polyfill()
          {
              Index = index,
              TypeName = typeName,
              OutputPath = Path.GetFileNameWithoutExtension(item)
                               .Replace(';', '_')
                               .Replace('@', '_') + ".g.cs",
              CSharpName = Path.GetFileNameWithoutExtension(item)
                               .Replace(';', '_')
                               .Replace('@', '_')
                               .Replace('{', '_')
                               .Replace('}', '_')
                               .Replace('(', '_')
                               .Replace(')', '_')
                               .Replace(',', '_')
                               .Replace('.', '_')
                               .Replace('`', '_'),
              PolyfillData = PolyfillData.Get($$""""
                  // <auto-generated/>
                  #pragma warning disable
                  #nullable enable annotations
                  {{ReadResourceAsString(item)}}
                  """"),
          };
      })
      .ToArray();

polyfills = SortPolyfills(polyfills);

var requiredTypes = polyfills.SelectMany(p => p.PolyfillData.RequiredTypes)
    .Distinct(StringComparer.Ordinal)
    .Order(StringComparer.Ordinal)
    .Select(p => new
    {
        TypeName = p,
        CsharpFieldName = "_" + p.Replace('`', '_').Replace('.', '_')
    })
    .ToArray();

var fieldCount = (polyfills.Length / 64) + (polyfills.Length % 64 > 0 ? 1 : 0);

var sb = new StringBuilder();
sb.AppendLine($$"""
    #nullable enable
    using System;
    using System.Text;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.Text;

    namespace Meziantou.Polyfill;

    internal readonly partial struct Members : IEquatable<Members>
    {
    """);

for (var i = 0; i < fieldCount; i++)
{
    sb.AppendLine($"private readonly ulong _bits{i} = 0uL;");
}

sb.AppendLine($"private readonly PolyfillOptions _options;");

foreach (var requiredType in requiredTypes)
{
    sb.AppendLine($"private readonly bool {requiredType.CsharpFieldName};");
}

sb.AppendLine("public Members(Compilation compilation, PolyfillOptions options)");
sb.AppendLine("{");
sb.AppendLine("    _options = options;");

foreach (var requiredType in requiredTypes)
{
    sb.AppendLine($"{requiredType.CsharpFieldName} = compilation.GetTypeByMetadataName(\"{requiredType.TypeName}\") != null;");
}

foreach (var polyfill in polyfills)
{
    sb.AppendLine($"    if ({GenerateIncludePreCondition(polyfill.PolyfillData)}IncludeMember(compilation, options, \"{polyfill.TypeName}\"){GenerateIncludePostCondition(polyfill.PolyfillData)})");
    sb.AppendLine($"        {polyfill.CSharpFieldName} = {polyfill.CSharpFieldName} | {polyfill.CSharpFieldBitMask}uL;");

    string GenerateIncludePreCondition(PolyfillData data)
    {
        var result = "";

        foreach (var requiredType in data.RequiredTypes)
        {
            result += requiredTypes.Single(t => t.TypeName == requiredType).CsharpFieldName + " && ";
        }

        if (data.ConditionalMembers.Length > 0)
        {
            result += "(";
            result += string.Join(" || ", data.ConditionalMembers.Select(member =>
            {
                var dependency = polyfills.Single(p => p.TypeName == member);
                return $"({dependency.CSharpFieldName} & {dependency.CSharpFieldBitMask}ul) == {dependency.CSharpFieldBitMask}ul";
            }));
            result += ") && ";
        }
        return result;
    }

    string GenerateIncludePostCondition(PolyfillData data)
    {
        var result = "";
        if (polyfill.TypeName.StartsWith("M:", StringComparison.Ordinal) && data.DeclaredMemberDocumentationIds.Length > 0)
        {
            result += " && (";
            result += string.Join(" && ", data.DeclaredMemberDocumentationIds.Select(member =>
            {
                return $"IncludeMember(compilation, options, \"{member}\")";
            }));
            result += ")";
        }

        return result;
    }
}
sb.AppendLine("}");



sb.AppendLine("public override int GetHashCode()");
sb.AppendLine("{");
sb.AppendLine("    var hash = _bits0.GetHashCode();");
for (var i = 1; i < fieldCount; i++)
{
    sb.AppendLine($"    hash = hash * 23 + _bits{i}.GetHashCode();");
}

sb.AppendLine("    return hash;");
sb.AppendLine("}");



sb.AppendLine("public override bool Equals(object? obj) => obj is Members other && Equals(other);");
sb.Append("public bool Equals(Members other) => _bits0 == other._bits0");
for (var i = 1; i < fieldCount; i++)
{
    sb.Append($"  && _bits{i} == other._bits{i}");
}
sb.AppendLine(";");


sb.AppendLine("public void AddSources(SourceProductionContext context)");
sb.AppendLine("{");
foreach (var polyfill in polyfills)
{
    sb.AppendLine($"    if (({polyfill.CSharpFieldName} & {polyfill.CSharpFieldBitMask}ul) == {polyfill.CSharpFieldBitMask}ul)");
    sb.AppendLine($"        context.AddSource(\"{polyfill.OutputPath}\", PolyfillContents.{polyfill.CSharpSourceTextPropertyName});");
}
sb.AppendLine("}");

sb.AppendLine("public string DumpAsCSharpComment()");
sb.AppendLine("{");
sb.AppendLine("    var sb = new StringBuilder();");
sb.AppendLine("    sb.AppendLine(_options.DumpAsCSharpComment());");
foreach (var requiredType in requiredTypes)
{
    sb.AppendLine($"    sb.AppendLine(\"// {requiredType.TypeName}: \" + {requiredType.CsharpFieldName});");
}

sb.AppendLine("    sb.AppendLine(\"//\");");
foreach (var polyfill in polyfills)
{
    sb.AppendLine($"    sb.AppendLine(\"// {polyfill.TypeName}: \" + (({polyfill.CSharpFieldName} & {polyfill.CSharpFieldBitMask}ul) == {polyfill.CSharpFieldBitMask}ul));");
}

sb.AppendLine("    return sb.ToString();");
sb.AppendLine("}");

sb.AppendLine("}");

sb.AppendLine("file static class PolyfillContents");
sb.AppendLine("{");
foreach (var polyfill in polyfills)
{
    sb.AppendLine($"public static SourceText {polyfill.CSharpSourceTextPropertyName} {{ get; }} = SourceText.From(\"\"\"\"\"\"\"\"\"\"");
    sb.AppendLine(polyfill.PolyfillData.Content);
    sb.AppendLine("\"\"\"\"\"\"\"\"\"\", Encoding.UTF8);");
}
sb.AppendLine("}");

Console.WriteLine(sb.ToString());
var path = GetMemberFilePath();
Console.WriteLine(path);
File.WriteAllText(path, sb.ToString());

static string GetMemberFilePath()
{
    var suffix = "Meziantou.Polyfill/Members.cs";
    var currentFolder = Environment.CurrentDirectory;
    var fullPath = Path.GetFullPath(Path.Combine(currentFolder, suffix));
    while (!File.Exists(fullPath))
    {
        currentFolder = Path.GetDirectoryName(currentFolder);
        if (currentFolder == null)
            throw new Exception("Cannot find the path from " + Environment.CurrentDirectory);

        fullPath = Path.GetFullPath(Path.Combine(currentFolder, suffix));
    }

    return Path.ChangeExtension(fullPath, ".g.cs");
}

string ReadResourceAsString(string name)
{
    using var sr = new StreamReader(assembly.GetManifestResourceStream(name)!);
    return sr.ReadToEnd();
}

static Polyfill[] SortPolyfills(Polyfill[] items)
{
    var result = new List<Polyfill>(items.Length);
    var remainingItems = items.ToList();
    while (remainingItems.Count > 0)
    {
        foreach (var item in remainingItems.Where(CanAddItem).OrderBy(i => i.Index).ToList())
        {
            result.Add(item);
            remainingItems.Remove(item);
        }
    }

    return result.ToArray();

    bool CanAddItem(Polyfill polyfill)
    {
        if (polyfill.PolyfillData.ConditionalMembers.Length == 0)
            return true;

        if (polyfill.PolyfillData.ConditionalMembers.All(m => result.Find(i => i.TypeName == m) != null))
            return true;

        return false;
    }
}

sealed class Polyfill
{
    public required int Index { get; set; }
    public required string TypeName { get; set; }
    public required string CSharpName { get; set; }
    public required PolyfillData PolyfillData { get; set; }
    public required string OutputPath { get; set; }

    public string CSharpFieldName => "_bits" + (Index / 64);
    public int CSharpFieldBitIndex => Index % 64;
    public ulong CSharpFieldBitMask => 1uL << (Index % 64);
    public string CSharpSourceTextPropertyName => "Source_" + CSharpName;

    public override string ToString()
    {
        return TypeName;
    }
}