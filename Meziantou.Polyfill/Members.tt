<#@ template language="C#" hostSpecific="true" debug="True" #>
<#@ output extension="g.cs" #>

<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#
    var root = Host.ResolvePath("../Meziantou.Polyfill.Editor");
    var files = Directory.GetFiles(root, "*.cs")
        .OrderBy(_ => _, StringComparer.Ordinal)
        .Select(item =>
        {
            var polyfill = new Polyfill();
            polyfill.TypeName = Path.GetFileNameWithoutExtension(item).Replace(';', ':');
            polyfill.OutputPath = Path.GetFileNameWithoutExtension(item)
                .Replace(';', '_')
                .Replace('@', '_')
                + ".g.cs";
            polyfill.CSharpName = Path.GetFileNameWithoutExtension(item)
                .Replace(';', '_')
                .Replace('@', '_')
                .Replace('{', '_')
                .Replace('}', '_')
                .Replace('(', '_')
                .Replace(')', '_')
                .Replace(',', '_')
                .Replace('.', '_')
                .Replace('`', '_');
            polyfill.Content = File.ReadAllText(item);
            return polyfill;
        })
        .ToArray();
#>
#nullable enable
using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Meziantou.Polyfill;

internal sealed partial class Members : IEquatable<Members>
{
    <# foreach(var polyfill in files) { #>
    private readonly bool <#= polyfill.CSharpFieldName #>;
    <# } #>
    
    public Members(Compilation compilation, PolyfillOptions options)
    {
    <# foreach(var polyfill in files) { #>
        
        <#= polyfill.CSharpFieldName #> = IncludeMember(compilation, options, "<#= polyfill.TypeName #>");
    <# } #>
    }


    public override int GetHashCode()
    {    
        var hash = 0;
        <# foreach(var polyfill in files) { #>
        hash = hash * 23 + <#= polyfill.CSharpFieldName #>.GetHashCode();
        <# } #>
        return hash;
    }

    public override bool Equals(object? obj) => obj is Members other && Equals(other);

    public bool Equals(Members? other)
    {
        return other != null
        <# foreach(var polyfill in files) { #>
        && <#= polyfill.CSharpFieldName #> == other.<#= polyfill.CSharpFieldName #>
        <# } #>;
    }

    public void AddSources(SourceProductionContext context)
    {
        <# foreach(var polyfill in files) { #>
        if (<#= polyfill.CSharpFieldName #>)
        {
            context.AddSource("<#= polyfill.OutputPath #>", PolyfillContents.<#= polyfill.CSharpSourceTextPropertyName #>);
        }        
        <# } #>
    }
}

file static class PolyfillContents
{
    <# foreach(var polyfill in files) { #>
    public static SourceText <#= polyfill.CSharpSourceTextPropertyName #> { get; } = SourceText.From(""""""""""
// <auto-generated/>
#pragma warning disable
#nullable enable annotations

<#= polyfill.Content #>
"""""""""", Encoding.UTF8);
    <# } #>

}

<#+
    class Polyfill
    {
        public string TypeName { get; set; }
        public string CSharpName { get; set; }
        public string Content { get; set; }
        public string OutputPath { get; set; }

        public string CSharpFieldName => "_generate_" + CSharpName;
        public string CSharpSourceTextPropertyName  => "Source_" + CSharpName;
    }
#>