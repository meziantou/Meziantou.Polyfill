<#@ template language="C#" hostSpecific="true" debug="True" #>
<#@ output extension="g.cs" #>

<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#
    var root = Host.ResolvePath("../Meziantou.Polyfill.Editor");
    var files = Directory.GetFiles(root, "*.cs")
        .OrderBy(_ => _, StringComparer.Ordinal)
        .Select((item, index) =>
        {
            var polyfill = new Polyfill();
            polyfill.Index = index;
            polyfill.TypeName = Path.GetFileNameWithoutExtension(item).Replace(';', ':');
            polyfill.OutputPath = Path.GetFileNameWithoutExtension(item)
                .Replace(';', '_')
                .Replace('@', '_')
                + ".g.cs";
            polyfill.CSharpName = Path.GetFileNameWithoutExtension(item)
                .Replace(';', '_')
                .Replace('@', '_')
                .Replace('{', '_')
                .Replace('}', '_')
                .Replace('(', '_')
                .Replace(')', '_')
                .Replace(',', '_')
                .Replace('.', '_')
                .Replace('`', '_');
            polyfill.Content = File.ReadAllText(item);
            return polyfill;
        })
        .ToArray();

    var fieldCount = (files.Length / 64) + (files.Length % 64 > 0 ? 1 : 0);
#>
#nullable enable
using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Meziantou.Polyfill;

internal readonly partial struct Members : IEquatable<Members>
{
    <# for(var i = 0; i < fieldCount; i++) { #>
    private readonly ulong _bits<#= i #> = 0uL;
    <# } #>
        
    public Members(Compilation compilation, PolyfillOptions options)
    {
    <# foreach(var polyfill in files) { #>
        if (IncludeMember(compilation, options, "<#= polyfill.TypeName #>"))
        {
            <#= polyfill.CSharpFieldName #> = <#= polyfill.CSharpFieldName #> | <#= polyfill.CSharpFieldBitMask #>uL;
        }
    <# } #>
    }


    public override int GetHashCode()
    {    
        var hash = _bits0.GetHashCode();
        <# for(var i = 1; i < fieldCount; i++) { #>
        hash = hash * 23 + _bits<#= i #>.GetHashCode();
        <# } #>
        return hash;
    }

    public override bool Equals(object? obj) => obj is Members other && Equals(other);

    public bool Equals(Members other)
    {
        return _bits0 == other._bits0
        <# for(var i = 1; i < fieldCount; i++) { #>
          && _bits<#= i #> == other._bits<#= i #>
        <# } #>;
    }

    public void AddSources(SourceProductionContext context)
    {
        <# foreach(var polyfill in files) { #>
        if ((<#= polyfill.CSharpFieldName #> & <#= polyfill.CSharpFieldBitMask #>uL) == <#= polyfill.CSharpFieldBitMask #>uL)
        {
            context.AddSource("<#= polyfill.OutputPath #>", PolyfillContents.<#= polyfill.CSharpSourceTextPropertyName #>);
        }        
        <# } #>
    }
}

file static class PolyfillContents
{
    <# foreach(var polyfill in files) { #>
    public static SourceText <#= polyfill.CSharpSourceTextPropertyName #> { get; } = SourceText.From(""""""""""
// <auto-generated/>
#pragma warning disable
#nullable enable annotations

<#= polyfill.Content #>
"""""""""", Encoding.UTF8);
    <# } #>

}

<#+
    class Polyfill
    {
        public int Index { get; set; }
        public string TypeName { get; set; }
        public string CSharpName { get; set; }
        public string Content { get; set; }
        public string OutputPath { get; set; }

        public string CSharpFieldName => "_bits" + (Index / 64);
        public int CSharpFieldBitIndex => Index % 64;
        public ulong CSharpFieldBitMask => 1uL << (Index % 64);
        public string CSharpSourceTextPropertyName  => "Source_" + CSharpName;
    }
#>